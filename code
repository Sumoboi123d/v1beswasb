--[[
    Player ESP (Filled Highlight + small name) — clean UI
    Fix: Highlight no longer disappears when players go invisible.
    Uses a client-only proxy rig when the real character is hidden.

    + Adds: "first-floor only" RemainingTime timers per plot (shows ONE per plot)
      • Tied to the same ON/OFF toggle as ESP
      • Zero behavior changes elsewhere

    PERF UPDATES (no feature changes):
      • Removed O(n^2) lookup in Heartbeat by storing Character in packet
      • Throttled proxy sync to 20 Hz instead of every Heartbeat
]]--

--// Services
local Players            = game:GetService("Players")
local UserInputService   = game:GetService("UserInputService")
local RunService         = game:GetService("RunService")
local LocalPlayer        = Players.LocalPlayer
local Camera             = workspace.CurrentCamera

--// Config
local HOTKEY_TOGGLE      = Enum.KeyCode.T

-- Name tag
local NAME_TEXT_SIZE     = 14
local NAME_FONT          = Enum.Font.GothamSemibold
local NAME_COLOR         = Color3.fromRGB(255,255,255)
local NAME_STROKE        = Color3.fromRGB(10,10,10)
local NAME_MAX_DISTANCE  = 600

-- Highlight styling (filled = "morphs" to avatar)
local HIGHLIGHT_FILL_COLOR           = Color3.fromRGB(65, 105, 225) -- RoyalBlue
local HIGHLIGHT_FILL_TRANSPARENCY    = 0.10                         -- less transparent
local HIGHLIGHT_OUTLINE_COLOR        = Color3.fromRGB(65, 105, 225) -- RoyalBlue
local HIGHLIGHT_OUTLINE_TRANSPARENCY = 0.15                         -- more visible outline

-- Panel styling
local PANEL_PRIMARY      = Color3.fromRGB(28, 28, 33)
local PANEL_ACCENT       = Color3.fromRGB(235, 64, 52)
local PANEL_TEXT         = Color3.fromRGB(235, 235, 235)

--// State
local ESPEnabled         = true
type Packet = {
    Highlight: Highlight?,
    Billboard: BillboardGui?,
    Label: TextLabel?,
    Head: BasePart?,
    HRP: BasePart?,
    Character: Model?,             -- PERF: keep direct ref (removes O(n^2) search)
    ProxyRig: Model?,
    ProxyMap: {[BasePart]: BasePart}?
}
local PerPlayer: {[Player]: Packet} = {}
local Connections: {[Player]: {RBXScriptConnection}} = {}

-- Folder to hold proxy rigs (keeps workspace tidy)
local PROXY_FOLDER = workspace:FindFirstChild("_ESP_ProxyRigs") :: Folder
if not PROXY_FOLDER then
    PROXY_FOLDER = Instance.new("Folder")
    PROXY_FOLDER.Name = "_ESP_ProxyRigs"
    PROXY_FOLDER.Parent = workspace
end

--// UI: control panel (clean + drag handle)
local controlGui = Instance.new("ScreenGui")
controlGui.Name = "ESPControlGui"
controlGui.IgnoreGuiInset = false -- don't overlap toolbar/topbar
controlGui.ResetOnSpawn = false
controlGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
controlGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local panel = Instance.new("Frame")
panel.Name = "ESPPanel"
panel.Size = UDim2.fromOffset(200, 60)
panel.Position = UDim2.fromOffset(24, 120)
panel.BackgroundColor3 = PANEL_PRIMARY
panel.BorderSizePixel = 0
panel.Parent = controlGui

local uiCorner = Instance.new("UICorner")
uiCorner.CornerRadius = UDim.new(0, 10)
uiCorner.Parent = panel

local stroke = Instance.new("UIStroke")
stroke.Thickness = 1
stroke.Color = Color3.fromRGB(60, 60, 68)
stroke.Transparency = 0.25
stroke.Parent = panel

local title = Instance.new("TextLabel")
title.BackgroundTransparency = 1
title.Size = UDim2.new(1, -12, 0, 20)
title.Position = UDim2.fromOffset(10, 6)
title.Font = Enum.Font.GothamBold
title.TextSize = 15
title.TextXAlignment = Enum.TextXAlignment.Left
title.Text = "ESP"
title.TextColor3 = PANEL_TEXT
title.Parent = panel

local hint = Instance.new("TextLabel")
hint.BackgroundTransparency = 1
hint.Size = UDim2.new(1, -12, 0, 16)
hint.Position = UDim2.fromOffset(10, 26)
hint.Font = Enum.Font.Gotham
hint.TextSize = 12
hint.TextXAlignment = Enum.TextXAlignment.Left
hint.TextTransparency = 0.2
hint.Text = "T to toggle"
hint.TextColor3 = Color3.fromRGB(200, 200, 210)
hint.Parent = panel

local toggleBtn = Instance.new("TextButton")
toggleBtn.Name = "Toggle"
toggleBtn.Size = UDim2.fromOffset(84, 28)
toggleBtn.Position = UDim2.new(1, -10 - 84, 1, -8 - 28)
toggleBtn.BackgroundColor3 = PANEL_ACCENT
toggleBtn.BorderSizePixel = 0
toggleBtn.AutoButtonColor = true
toggleBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
toggleBtn.Font = Enum.Font.GothamSemibold
toggleBtn.TextSize = 14
toggleBtn.Text = "ON"
toggleBtn.Parent = panel

local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0, 8)
toggleCorner.Parent = toggleBtn

-- drag handle (top strip only)
local dragHandle = Instance.new("Frame")
dragHandle.Name = "DragHandle"
dragHandle.BackgroundTransparency = 1
dragHandle.Size = UDim2.new(1, -8, 0, 34)
dragHandle.Position = UDim2.fromOffset(4, 4)
dragHandle.ZIndex = panel.ZIndex + 1
dragHandle.Parent = panel

-- Smooth, bounded dragging
do
    local dragging = false
    local dragOffset = Vector2.zero
    local function clampToViewport(px, py)
        local vp = Camera.ViewportSize
        local sz = panel.AbsoluteSize
        local x = math.clamp(px, 0, math.max(0, vp.X - sz.X))
        local y = math.clamp(py, 0, math.max(0, vp.Y - sz.Y))
        return x, y
    end

    dragHandle.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragOffset = input.Position - panel.AbsolutePosition
        end
    end)

    UserInputService.InputEnded:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = false
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local rawX = input.Position.X - dragOffset.X
            local rawY = input.Position.Y - dragOffset.Y
            local x, y = clampToViewport(rawX, rawY)
            panel.Position = UDim2.fromOffset(x, y)
        end
    end)

    Camera:GetPropertyChangedSignal("ViewportSize"):Connect(function()
        local pos = panel.AbsolutePosition
        local x, y = clampToViewport(pos.X, pos.Y)
        panel.Position = UDim2.fromOffset(x, y)
    end)
end

-- Toggle visuals
local function setToggleVisual(on: boolean)
    if on then
        toggleBtn.Text = "ON"
        toggleBtn.BackgroundColor3 = PANEL_ACCENT
        toggleBtn.TextColor3 = Color3.fromRGB(255,255,255)
    else
        toggleBtn.Text = "OFF"
        toggleBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 78)
        toggleBtn.TextColor3 = Color3.fromRGB(220,220,230)
    end
end

-- Helpers
local function cleanupPlayer(player: Player)
    if Connections[player] then
        for _, c in ipairs(Connections[player]) do
            pcall(function() c:Disconnect() end)
        end
        Connections[player] = nil
    end
    local pkt = PerPlayer[player]
    if not pkt then return end
    if pkt.Highlight then pkt.Highlight:Destroy() end
    if pkt.Billboard then pkt.Billboard:Destroy() end
    if pkt.ProxyRig then pkt.ProxyRig:Destroy() end
    PerPlayer[player] = nil
end

local function makeNameBillboard(head: BasePart, player: Player)
    local bb = Instance.new("BillboardGui")
    bb.Name = "ESP_NameTag"
    bb.Size = UDim2.new(0, 140, 0, 22)
    bb.StudsOffset = Vector3.new(0, 3.0, 0)
    bb.AlwaysOnTop = true
    bb.MaxDistance = NAME_MAX_DISTANCE
    bb.Parent = head

    local label = Instance.new("TextLabel")
    label.BackgroundTransparency = 1
    label.Size = UDim2.new(1, 0, 1, 0)
    label.TextColor3 = NAME_COLOR
    label.TextStrokeColor3 = NAME_STROKE
    label.TextStrokeTransparency = 0.45
    label.Font = NAME_FONT
    label.TextScaled = false
    label.TextSize = NAME_TEXT_SIZE
    label.Text = (player.DisplayName ~= "" and player.DisplayName or player.Name)
    label.Parent = bb

    return bb, label
end

-- NEW: Make a lightweight, client-only proxy rig with anchored parts
local function createProxyRigFor(character: Model): (Model, {[BasePart]: BasePart})
    local proxy = Instance.new("Model")
    proxy.Name = "_ESPProxy_" .. (character:GetFullName():gsub("%W",""))
    proxy.Parent = PROXY_FOLDER

    local map: {[BasePart]: BasePart} = {}
    for _, desc in ipairs(character:GetDescendants()) do
        if desc:IsA("BasePart") then
            local p = Instance.new("Part")
            p.Anchored = true
            p.CanCollide = false
            p.CanTouch = false
            p.CanQuery = false
            p.CastShadow = false
            p.Size = desc.Size
            p.CFrame = desc.CFrame
            p.Transparency = 0.999
            p.Material = Enum.Material.SmoothPlastic
            p.Name = "Proxy_" .. desc.Name
            p.Parent = proxy
            map[desc] = p
        end
    end
    return proxy, map
end

-- Check if a character is “invisible” (all main parts hidden)
local MAIN_PART_NAMES = {
    Head=true, UpperTorso=true, LowerTorso=true, Torso=true,
    LeftUpperArm=true, LeftLowerArm=true, LeftHand=true,
    RightUpperArm=true, RightLowerArm=true, RightHand=true,
    LeftUpperLeg=true, LeftLowerLeg=true, LeftFoot=true,
    RightUpperLeg=true, RightLowerLeg=true, RightFoot=true,
    ["Left Arm"]=true, ["Right Arm"]=true, ["Left Leg"]=true, ["Right Leg"]=true,
}

local function isCharacterInvisible(character: Model): boolean
    local anyVisible = false
    for _, desc in ipairs(character:GetDescendants()) do
        if desc:IsA("BasePart") and MAIN_PART_NAMES[desc.Name] then
            local lt = (desc.LocalTransparencyModifier or 0)
            local t  = desc.Transparency
            if (lt < 0.95) and (t < 0.95) then
                anyVisible = true
                break
            end
        end
    end
    return not anyVisible
end

-- Keep a proxy rig in sync with the source character
local function updateProxyFromCharacter(map: {[BasePart]: BasePart}, character: Model)
    for src, proxyPart in pairs(map) do
        if src and src.Parent and proxyPart and proxyPart.Parent then
            local ok1 = pcall(function() proxyPart.CFrame = src.CFrame end)
            if ok1 and proxyPart.Size ~= src.Size then
                pcall(function() proxyPart.Size = src.Size end)
            end
        end
    end
end

local function ensureProxyActive(pkt: Packet, character: Model)
    if not pkt.ProxyRig or not pkt.ProxyRig.Parent then
        local proxy, map = createProxyRigFor(character)
        pkt.ProxyRig = proxy
        pkt.ProxyMap = map
    end
end

local function destroyProxy(pkt: Packet)
    if pkt.ProxyRig then pkt.ProxyRig:Destroy() end
    pkt.ProxyRig = nil
    pkt.ProxyMap = nil
end

--========================================================--
-- First-floor-only RemainingTime (ONE timer per plot)
--========================================================--
local PLOTS = workspace:FindFirstChild("Plots")
local FIRST_FLOOR_MAX_DISTANCE = 99999
local FIRST_FLOOR_SIZE = UDim2.new(30, 0, 30, 0)

local function firstFloorHideAll()
    if not PLOTS then return end
    for _, v in ipairs(PLOTS:GetDescendants()) do
        if v.Name == "RemainingTime" and v.Parent and v.Parent:IsA("BillboardGui") then
            (v.Parent :: BillboardGui).Enabled = false
        end
    end
end

local function firstFloorRefresh()
    if not PLOTS then return end
    for _, plot in ipairs(PLOTS:GetChildren()) do
        local lowestGui: BillboardGui? = nil
        local lowestY = math.huge

        for _, d in ipairs(plot:GetDescendants()) do
            if d.Name == "RemainingTime" and d.Parent and d.Parent:IsA("BillboardGui") then
                local gui = d.Parent :: BillboardGui
                local y
                if gui.Adornee and gui.Adornee:IsA("BasePart") then
                    y = gui.Adornee.Position.Y
                elseif gui.Parent and gui.Parent:IsA("BasePart") then
                    y = (gui.Parent :: BasePart).Position.Y
                end
                if y and y < lowestY then
                    lowestY = y
                    lowestGui = gui
                end
            end
        end

        for _, d in ipairs(plot:GetDescendants()) do
            if d.Name == "RemainingTime" and d.Parent and d.Parent:IsA("BillboardGui") then
                local gui = d.Parent :: BillboardGui
                if gui == lowestGui then
                    gui.Enabled = ESPEnabled
                    gui.MaxDistance = FIRST_FLOOR_MAX_DISTANCE
                    gui.AlwaysOnTop = true
                    gui.Size = FIRST_FLOOR_SIZE
                else
                    gui.Enabled = false
                end
            end
        end
    end
end

if PLOTS then
    firstFloorRefresh()
    PLOTS.DescendantAdded:Connect(function(inst)
        if inst.Name == "RemainingTime" or (inst:IsA("BillboardGui") and inst:FindFirstChild("RemainingTime")) then
            task.defer(function()
                if ESPEnabled then firstFloorRefresh() end
            end)
        end
    end)
    PLOTS.DescendantRemoving:Connect(function(_)
        task.defer(function()
            if ESPEnabled then firstFloorRefresh() end
        end)
    end)
end
--========================================================--

-- Toggle all per-player visuals
local function enableESPForPlayer(player: Player, enable: boolean)
    local pkt = PerPlayer[player]
    if not pkt then return end

    if pkt.Highlight then
        pkt.Highlight.Enabled = enable
    end

    if pkt.Billboard then
        local ok = pcall(function()
            (pkt.Billboard :: any).Enabled = enable
        end)
        if not ok then
            if enable then
                if pkt.Head and pkt.Billboard.Parent ~= pkt.Head then
                    pkt.Billboard.Parent = pkt.Head
                end
            else
                pkt.Billboard.Parent = nil
            end
        end
    end

    if not enable then
        destroyProxy(pkt)
    end
end

local function setESPEnabled(on: boolean)
    ESPEnabled = on
    if on then
        toggleBtn.Text = "ON"; toggleBtn.BackgroundColor3 = PANEL_ACCENT
    else
        toggleBtn.Text = "OFF"; toggleBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 78)
    end
    for plr, _ in pairs(PerPlayer) do
        enableESPForPlayer(plr, on)
    end
    if PLOTS then
        if on then
            firstFloorRefresh()
        else
            firstFloorHideAll()
        end
    end
end

toggleBtn.MouseButton1Click:Connect(function()
    setESPEnabled(not ESPEnabled)
end)

UserInputService.InputBegan:Connect(function(input, gp)
    if gp then return end
    if input.KeyCode == HOTKEY_TOGGLE then
        setESPEnabled(not ESPEnabled)
    end
end)

-- Attach ESP for a character
local function attachForCharacter(player: Player, character: Model)
    if player == LocalPlayer then return end

    local head: BasePart? = character:FindFirstChild("Head") :: BasePart?
    local hrp: BasePart?  = character:FindFirstChild("HumanoidRootPart") :: BasePart?
    if not head or not hrp then
        head = character:WaitForChild("Head", 5)
        hrp  = character:WaitForChild("HumanoidRootPart", 5)
        if not head or not hrp then return end
    end

    local hl = Instance.new("Highlight")
    hl.Name = "ESP_Highlight"
    hl.Adornee = character
    hl.FillColor = HIGHLIGHT_FILL_COLOR
    hl.FillTransparency = HIGHLIGHT_FILL_TRANSPARENCY
    hl.OutlineColor = HIGHLIGHT_OUTLINE_COLOR
    hl.OutlineTransparency = HIGHLIGHT_OUTLINE_TRANSPARENCY
    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    hl.Enabled = ESPEnabled
    hl.Parent = character

    local bb, label = makeNameBillboard(head, player)
    if not ESPEnabled then bb.Parent = nil end

    PerPlayer[player] = {
        Highlight = hl,
        Billboard = bb,
        Label = label,
        Head = head,
        HRP = hrp,
        Character = character, -- PERF: store direct ref
        ProxyRig = nil,
        ProxyMap = nil
    }
end

-- Player event wiring
local function onPlayerAdded(player: Player)
    local nameConn = player:GetPropertyChangedSignal("DisplayName"):Connect(function()
        local pkt = PerPlayer[player]
        if pkt and pkt.Label then
            local base = (player.DisplayName ~= "" and player.DisplayName or player.Name)
            pkt.Label.Text = base
        end
    end)

    local charConn = player.CharacterAdded:Connect(function(char)
        task.defer(function()
            attachForCharacter(player, char)
            enableESPForPlayer(player, ESPEnabled)
        end)
    end)

    Connections[player] = Connections[player] or {}
    table.insert(Connections[player], nameConn)
    table.insert(Connections[player], charConn)

    if player.Character then
        attachForCharacter(player, player.Character)
        enableESPForPlayer(player, ESPEnabled)
    end
end

local function onPlayerRemoving(player: Player)
    cleanupPlayer(player)
end

-- Init
for _, plr in ipairs(Players:GetPlayers()) do
    if plr ~= LocalPlayer then
        onPlayerAdded(plr)
    end
end
Players.PlayerAdded:Connect(onPlayerAdded)
Players.PlayerRemoving:Connect(onPlayerRemoving)

-- Distance + invisibility updater (same cadence)
task.spawn(function()
    while true do
        task.wait(0.3)
        if not ESPEnabled then continue end
        for plr, pkt in pairs(PerPlayer) do
            if pkt and pkt.Label and pkt.HRP then
                local lpChar = LocalPlayer.Character
                local lpRoot = lpChar and lpChar:FindFirstChild("HumanoidRootPart")
                if lpRoot then
                    local dist = math.floor((lpRoot.Position - pkt.HRP.Position).Magnitude + 0.5)
                    local base = (plr.DisplayName ~= "" and plr.DisplayName or plr.Name)
                    pkt.Label.Text = string.format("%s  [%dm]", base, dist)
                end
            end

            local char = pkt.Character
            if char and pkt.Highlight then
                local invisible = isCharacterInvisible(char)
                if invisible then
                    ensureProxyActive(pkt, char)
                    if pkt.ProxyRig and pkt.ProxyMap then
                        pkt.Highlight.Adornee = pkt.ProxyRig
                    end
                else
                    if pkt.Highlight.Adornee ~= char then
                        pkt.Highlight.Adornee = char
                    end
                    destroyProxy(pkt)
                end
            end
        end
    end
end)

-- PERF: throttle proxy sync to 20 Hz (reduces CPU without changing visuals)
local PROXY_UPDATE_INTERVAL = 1/20
local accum = 0
RunService.Heartbeat:Connect(function(dt)
    accum += dt
    if accum < PROXY_UPDATE_INTERVAL then return end
    accum -= PROXY_UPDATE_INTERVAL

    for _, pkt in pairs(PerPlayer) do
        if pkt and pkt.ProxyRig and pkt.ProxyMap and pkt.Character then
            updateProxyFromCharacter(pkt.ProxyMap, pkt.Character)
        end
    end
end)

-- External toggle if your executor UI wants to call it
toggleBtn.Text = "ON"; toggleBtn.BackgroundColor3 = PANEL_ACCENT
_G.SetESPEnabled = function(on)
    setESPEnabled(on and true or false)
end
